# The type checking monad

```agda
{-# OPTIONS --no-exact-split #-}

module reflection.type-checking-monad where
```

<details><summary>Imports</summary>

```agda
open import elementary-number-theory.addition-natural-numbers
open import elementary-number-theory.natural-numbers

open import foundation.booleans
open import foundation.cartesian-product-types
open import foundation.dependent-pair-types
open import foundation.identity-types
open import foundation.unit-type
open import foundation.universe-levels

open import lists.lists

open import primitives.strings

open import reflection.arguments
open import reflection.definitions
open import reflection.metavariables
open import reflection.names
open import reflection.terms
```

</details>

## Idea

The type-checking monad `TC` allows us to interact directly with Agda's type
checking mechanism. Additionally to primitives (see below), Agda includes the
the keyword `unquote` to manually unquote an element from `TC unit`.

## Definition

```agda
data ErrorPart : UU lzero where
  strErr : String ‚Üí ErrorPart
  termErr : Term-Agda ‚Üí ErrorPart
  pattErr : Pattern-Agda ‚Üí ErrorPart
  nameErr : Name-Agda ‚Üí ErrorPart

postulate
  -- The type checking monad
  TC : ‚àÄ {a} ‚Üí UU a ‚Üí UU a
  returnTC : ‚àÄ {a} {A : UU a} ‚Üí A ‚Üí TC A
  bindTC : ‚àÄ {a b} {A : UU a} {B : UU b} ‚Üí TC A ‚Üí (A ‚Üí TC B) ‚Üí TC B
  -- Tries the unify the first term with the second
  unify : Term-Agda ‚Üí Term-Agda ‚Üí TC unit
  -- Gives an error
  typeError : ‚àÄ {a} {A : UU a} ‚Üí list ErrorPart ‚Üí TC A
  -- Infers the type of a goal
  inferType : Term-Agda ‚Üí TC Term-Agda
  checkType : Term-Agda ‚Üí Term-Agda ‚Üí TC Term-Agda
  normalise : Term-Agda ‚Üí TC Term-Agda
  reduce : Term-Agda ‚Üí TC Term-Agda
  -- Tries the first computation, if it fails tries the second
  catchTC : ‚àÄ {a} {A : UU a} ‚Üí TC A ‚Üí TC A ‚Üí TC A
  quoteTC : ‚àÄ {a} {A : UU a} ‚Üí A ‚Üí TC Term-Agda
  unquoteTC : ‚àÄ {a} {A : UU a} ‚Üí Term-Agda ‚Üí TC A
  quoteœâTC : ‚àÄ {A : UUœâ} ‚Üí A ‚Üí TC Term-Agda
  getContext : TC Telescope-Agda
  extendContext :
    ‚àÄ {a} {A : UU a} ‚Üí String ‚Üí Argument-Agda Term-Agda ‚Üí TC A ‚Üí TC A
  inContext : ‚àÄ {a} {A : UU a} ‚Üí Telescope-Agda ‚Üí TC A ‚Üí TC A
  freshName : String ‚Üí TC Name-Agda
  declareDef : Argument-Agda Name-Agda ‚Üí Term-Agda ‚Üí TC unit
  declarePostulate : Argument-Agda Name-Agda ‚Üí Term-Agda ‚Üí TC unit
  defineFun : Name-Agda ‚Üí list Clause-Agda ‚Üí TC unit
  getType : Name-Agda ‚Üí TC Term-Agda
  getDefinition : Name-Agda ‚Üí TC Definition-Agda
  blockTC : ‚àÄ {a} {A : UU a} ‚Üí Blocker-Agda ‚Üí TC A
  commitTC : TC unit
  isMacro : Name-Agda ‚Üí TC bool

  formatErrorParts : list ErrorPart ‚Üí TC String

  -- Prints the third argument if the corresponding verbosity level is turned
  -- on (with the -v flag to Agda).
  debugPrint : String ‚Üí ‚Ñï ‚Üí list ErrorPart ‚Üí TC unit

  -- If 'true', makes the following primitives also normalise
  -- their results: inferType, checkType, quoteTC, getType, and getContext
  withNormalisation : ‚àÄ {a} {A : UU a} ‚Üí bool ‚Üí TC A ‚Üí TC A
  askNormalisation : TC bool

  -- If 'true', makes the following primitives to reconstruct hidden arguments:
  -- getDefinition, normalise, reduce, inferType, checkType and getContext
  withReconstructed : ‚àÄ {a} {A : UU a} ‚Üí bool ‚Üí TC A ‚Üí TC A
  askReconstructed : TC bool

  -- Whether implicit arguments at the end should be turned into metavariables
  withExpandLast : ‚àÄ {a} {A : UU a} ‚Üí bool ‚Üí TC A ‚Üí TC A
  askExpandLast : TC bool

  -- White/blacklist specific definitions for reduction while executing the TC computation
  -- 'true' for whitelist, 'false' for blacklist
  withReduceDefs :
    ‚àÄ {a} {A : UU a} ‚Üí (Œ£ bool Œª _ ‚Üí list Name-Agda) ‚Üí TC A ‚Üí TC A
  askReduceDefs : TC (Œ£ bool Œª _ ‚Üí list Name-Agda)

  -- Fail if the given computation gives rise to new, unsolved
  -- "blocking" constraints.
  noConstraints : ‚àÄ {a} {A : UU a} ‚Üí TC A ‚Üí TC A

  -- Run the given TC action and return the first component. Resets to
  -- the old TC state if the second component is 'false', or keep the
  -- new TC state if it is 'true'.
  runSpeculative : ‚àÄ {a} {A : UU a} ‚Üí TC (Œ£ A Œª _ ‚Üí bool) ‚Üí TC A

  -- Get a list of all possible instance candidates for the given metavariable-Term-Agda
  -- variable (it does not have to be an instance metavariable-Term-Agda).
  getInstances : Metavariable-Agda ‚Üí TC (list Term-Agda)

  declareData : Name-Agda ‚Üí ‚Ñï ‚Üí Term-Agda ‚Üí TC unit
  defineData : Name-Agda ‚Üí list (Œ£ Name-Agda (Œª _ ‚Üí Term-Agda)) ‚Üí TC unit
```

<details><summary>Bindings</summary>

```agda
{-# BUILTIN AGDAERRORPART ErrorPart #-}
{-# BUILTIN AGDAERRORPARTSTRING strErr #-}
{-# BUILTIN AGDAERRORPARTTERM termErr #-}
{-# BUILTIN AGDAERRORPARTPATT pattErr #-}
{-# BUILTIN AGDAERRORPARTNAME nameErr #-}

{-# BUILTIN AGDATCM TC #-}
{-# BUILTIN AGDATCMRETURN returnTC #-}
{-# BUILTIN AGDATCMBIND bindTC #-}
{-# BUILTIN AGDATCMUNIFY unify #-}
{-# BUILTIN AGDATCMTYPEERROR typeError #-}
{-# BUILTIN AGDATCMINFERTYPE inferType #-}
{-# BUILTIN AGDATCMCHECKTYPE checkType #-}
{-# BUILTIN AGDATCMNORMALISE normalise #-}
{-# BUILTIN AGDATCMREDUCE reduce #-}
{-# BUILTIN AGDATCMCATCHERROR catchTC #-}
{-# BUILTIN AGDATCMQUOTETERM quoteTC #-}
{-# BUILTIN AGDATCMUNQUOTETERM unquoteTC #-}
{-# BUILTIN AGDATCMQUOTEOMEGATERM quoteœâTC #-}
{-# BUILTIN AGDATCMGETCONTEXT getContext #-}
{-# BUILTIN AGDATCMEXTENDCONTEXT extendContext #-}
{-# BUILTIN AGDATCMINCONTEXT inContext #-}
{-# BUILTIN AGDATCMFRESHNAME freshName #-}
{-# BUILTIN AGDATCMDECLAREDEF declareDef #-}
{-# BUILTIN AGDATCMDECLAREPOSTULATE declarePostulate #-}
{-# BUILTIN AGDATCMDEFINEFUN defineFun #-}
{-# BUILTIN AGDATCMGETTYPE getType #-}
{-# BUILTIN AGDATCMGETDEFINITION getDefinition #-}
{-# BUILTIN AGDATCMBLOCK blockTC #-}
{-# BUILTIN AGDATCMCOMMIT commitTC #-}
{-# BUILTIN AGDATCMISMACRO isMacro #-}
{-# BUILTIN AGDATCMWITHNORMALISATION withNormalisation #-}
{-# BUILTIN AGDATCMFORMATERRORPARTS formatErrorParts #-}
{-# BUILTIN AGDATCMDEBUGPRINT debugPrint #-}
{-# BUILTIN AGDATCMWITHRECONSTRUCTED withReconstructed #-}
{-# BUILTIN AGDATCMWITHEXPANDLAST withExpandLast #-}
{-# BUILTIN AGDATCMWITHREDUCEDEFS withReduceDefs #-}
{-# BUILTIN AGDATCMASKNORMALISATION askNormalisation #-}
{-# BUILTIN AGDATCMASKRECONSTRUCTED askReconstructed #-}
{-# BUILTIN AGDATCMASKEXPANDLAST askExpandLast #-}
{-# BUILTIN AGDATCMASKREDUCEDEFS askReduceDefs #-}
{-# BUILTIN AGDATCMNOCONSTRAINTS noConstraints #-}
{-# BUILTIN AGDATCMRUNSPECULATIVE runSpeculative #-}
{-# BUILTIN AGDATCMGETINSTANCES getInstances #-}
{-# BUILTIN AGDATCMDECLAREDATA declareData #-}
{-# BUILTIN AGDATCMDEFINEDATA defineData #-}
```

</details>

## Monad syntax

```agda
infixl 15 _<|>_
_<|>_ : {l : Level} {A : UU l} ‚Üí TC A ‚Üí TC A ‚Üí TC A
_<|>_ = catchTC

infixl 10 _>>=_ _>>_ _<&>_
_>>=_ :
  {l1 l2 : Level} {A : UU l1} {B : UU l2} ‚Üí
  TC A ‚Üí (A ‚Üí TC B) ‚Üí TC B
_>>=_ = bindTC

_>>_ :
  {l1 l2 : Level} {A : UU l1} {B : UU l2} ‚Üí
  TC A ‚Üí TC B ‚Üí TC B
xs >> ys = bindTC xs (Œª _ ‚Üí ys)

_<&>_ :
  {l1 l2 : Level} {A : UU l1} {B : UU l2} ‚Üí
  TC A ‚Üí (A ‚Üí B) ‚Üí TC B
xs <&> f = bindTC xs (Œª x ‚Üí returnTC (f x))
```

## Examples

The following examples show how the type-checking monad can be used. They were
adapted from alhassy's
[_gentle intro to reflection_](https://github.com/alhassy/gentle-intro-to-reflection).

### Unifying a goal with a constant

#### Manually

```agda
private
  numTCM : Term-Agda ‚Üí TC unit
  numTCM h = unify (quoteTerm 314) h

  _ : unquote numTCM Ôºù 314
  _ = refl
```

#### By use of a macro

```agda
  macro
    numTCM' : Term-Agda ‚Üí TC unit
    numTCM' h = unify (quoteTerm 1) h

  _ : numTCM' Ôºù 1
  _ = refl
```

### Modifying a term

```agda
  macro
    swap-add : Term-Agda ‚Üí Term-Agda ‚Üí TC unit
    swap-add (definition-Term-Agda (quote add-‚Ñï) (cons a (cons b nil))) hole =
      unify hole (definition-Term-Agda (quote add-‚Ñï) (cons b (cons a nil)))
    {-# CATCHALL #-}
    swap-add v hole = unify hole v

  ex1 : (a b : ‚Ñï) ‚Üí swap-add (add-‚Ñï a b) Ôºù (add-‚Ñï b a)
  ex1 a b = refl

  ex2 : (a b : ‚Ñï) ‚Üí swap-add a Ôºù a
  ex2 a b = refl
```

### Trying a path

The following example tries to solve a goal by using path `p` or `inv p`. This
example was addapted from

```agda
  private
    infixr 10 _‚à∑_
    pattern _‚à∑_ x xs = cons x xs

  Ôºù-type-info :
    Term-Agda ‚Üí
    TC
      ( Argument-Agda Term-Agda √ó
        ( Argument-Agda Term-Agda √ó
          ( Term-Agda √ó Term-Agda)))
  Ôºù-type-info
    ( definition-Term-Agda (quote _Ôºù_) (ùìÅ ‚à∑ ùíØ ‚à∑ (arg _ l) ‚à∑ (arg _ r) ‚à∑ nil)) =
    returnTC (ùìÅ , ùíØ , l , r)
  Ôºù-type-info _ = typeError (unit-list (strErr "Term-Agda is not a Ôºù-type."))

  macro
    try-path! : Term-Agda ‚Üí Term-Agda ‚Üí TC unit
    try-path! p goal =
      ( unify goal p) <|>
      ( do
        p-type ‚Üê inferType p
        ùìÅ , ùíØ , l , r ‚Üê Ôºù-type-info p-type
        unify goal
          ( definition-Term-Agda (quote inv)
            ( ùìÅ ‚à∑
              ùíØ ‚à∑
              hidden-Argument-Agda l ‚à∑
              hidden-Argument-Agda r ‚à∑
              visible-Argument-Agda p ‚à∑
              nil)))

  module _ (a b : ‚Ñï) (p : a Ôºù b) where
    ex3 : Id a b
    ex3 = try-path! p

    ex4 : Id b a
    ex4 = try-path! p
```

### Getting the lhs and rhs of a goal

```agda
boundary-TCM : Term-Agda ‚Üí TC (Term-Agda √ó Term-Agda)
boundary-TCM
  ( definition-Term-Agda
    ( quote Id)
    ( ùìÅ ‚à∑ ùíØ ‚à∑ arg _ l ‚à∑ arg _ r ‚à∑ nil)) =
  returnTC (l , r)
boundary-TCM t =
  typeError
    ( strErr "The term\n " ‚à∑
      termErr t ‚à∑
      strErr "\nis not a Ôºù-type." ‚à∑
      nil)
```
